# -*- coding: utf-8 -*-
"""Lab 14 Collaborative_Filtering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dun8V4th4pkFSXyj3w8igY2hEa0K9AB3

1. Implement the "user-based similarity" method of Collaborative Filtering. Upload the "ratings.csv". Create a frame for this file.
"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
df = pd.read_csv("/content/rating.csv")
df.head(5)

"""2. Drop the timestamp column and find the number of unique movies and unique users."""

df.drop('timestamp', axis = 1, inplace = True) 
print("No. of unique users =",len(df['userId'].unique()))
print("No. of unique movies =",len(df['movieId'].unique()))

"""3. Create a pivot table or matrix with users as rows and movies as columns. Matrix entries will represent the ratings given by the users. This will be a sparse matrix and those movies not watched will be NaN. Replace all such NaN values by zeros. """

user_movies_df = df.pivot(index = "userId", columns = "movieId", values = "rating").reset_index(drop = True)
user_movies_df.index = df.userId.unique()
user_movies_df.fillna(0, inplace = True)

"""4. Compute the cosine similarity matrix between all pairs of users.The diagonal values of this matrix will be 1. Print the matrix."""

from sklearn.metrics import pairwise_distances
from scipy.spatial.distance import cosine, correlation
user_sim = 1 - pairwise_distances(user_movies_df.values, metric = "cosine") 
#covert this matrix to a frame
user_sim_df = pd.DataFrame(user_sim)
#set the index and column names to user ids 
user_sim_df.index = df.userId.unique()
user_sim_df.columns = df.userId.unique()
user_sim_df.iloc[0:5, 0:5]

"""5. Set the diagonal values as 0.0, since we need to find other users who are similar to a specific user."""

import numpy as np
np.fill_diagonal(user_sim, 0)
user_sim_df.iloc[0:5, 0:5]

"""6. Filter similar users. To find most similar users, the maximum values of each column can be filtered. For example, the most similar user to first 5 users with userId from 1 to 5 can be printed as"""

user_sim_df.idxmax(axis=1)[0:5]

"""7. This result says that the most similar user to user1 is userId 2595 and so on.This also means that both have watched several movies in common and rated very similarly. This can be verified with the movies dataset. Load the movies dataset, drop the "genres" column.

"""

uploaded = files.upload()

movies_df = pd.read_csv("/content/movie.csv")
movies_df.drop('genres', axis = 1, inplace = True)
movies_df.iloc[0:5, 0:5]

"""8. Find common movies of similar users. """

def get_user_similar_movies(user1, user2):
  #Inner join of movies watched by both users will give the common movies
  common = df[df.userId == user1].merge(df[df.userId == user2], on = "movieId", how = "inner")
  #merge this result with movie details
  return common.merge(movies_df, on = "movieId")

"""9. Find the common movies of user 1 and user 2595.Print only those common movies with ratings above 4."""

common_movies = get_user_similar_movies(1,2595 )
#print(common_movies)
common_movies[(common_movies.rating_x >=4.0) & ((common_movies.rating_y >=4.0))]

"""10. Finding user similarity does not work for new users. We need to wait until the new user buys a few items and rates them. Only then user preferences can be founnd and recommendations can be made. This is called the "cold-start" problem in recommender systems. This is overcome by using item-based similarity methods. """